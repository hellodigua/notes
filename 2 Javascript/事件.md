title: Javascript事件总结
tags:
- Javascript
---
# 什么是事件

当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。

也就是说，我们与浏览器进行交互的过程就是触发各种事件的过程。这样，我们就可以编写js，通过监听某一个事件，来实现某些功能。
比如监听load事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。

# 基础事件操作

## 监听事件
如果我们需要针对某种事件进行处理，那么就要监听者个事件，监听事件的方法主要有以下三种：

### html内联属性（尽量避免使用）
html元素里直接填写事件属性，即可在触发事件的时候执行属性内容
<button onclick="alert('点击了按钮');">点击</button>
显而易见，该方法将js代码与html代码耦合在了一起，不便于维护和开发，除非在必须使用的情况下，尽量避免使用该方法。

### dom属性绑定
直接设置dom属性来指定某个事件对应的处理函数，这个方法比较简单：
element.onclick = function(event){
  alert('点击了按钮！');
}
该方法简单易懂，但是呢，它是直接赋值给对应属性，如果在后面的代码中再次为该element绑定一个回调函数，那么会覆盖掉之前回调函数的内容。
比如说一个元素既需要点击又需要鼠标滑过，那么当被声明鼠标滑过事件的时候，点击事件就被覆盖了！！！

### 事件监听函数（标准事件监听函数）
element.addEventListener(<event-name>, <callback>, <use-capture>);
表示在element对象上添加了一个事件监听器，当监听到有<event-name>事件发生的时候，调用<call-back>这个回调函数。
<use-capture>则表示该事件监听是在“捕获”阶段（true）中监听还是在“冒泡”阶段（false）中监听。
<script type="text/javascript">
  var btn = document.getElementById('button');
  btn[0].addEventListener('click', function(){
    alert('你点击了按钮！');
  }, false);
</script>

## 移除监听事件
当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用removeEventListener方法：
element.removeEventListener(<event-name>, <callback>, <use-capture>);
需要注意的是：绑定，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。
var fun = function(){
  ...
};
element.addEventListener('click', fun, false);
element.removeEventListener('click', fun, false);

#事件触发过程
事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。
两者的区别就是一个从下往上传播，一个从上往下传播。

## 事件冒泡
微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。

因此在事件冒泡的概念下在p元素上发生click事件的顺序应该是p -> div -> body -> html -> document -> window

## 事件捕获
网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。

因此在事件捕获的概念下在p元素上发生click事件的顺序应该是window -> document -> html -> body -> div -> p

## 兼容性问题
对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议使用事件冒泡模型。（false）

## 使用事件代理（Event Delegate）提升性能
因为事件有冒泡机制，所有子节点的事件都会顺着父级节点跑回去，所以我们可以通过监听父级节点来实现监听子节点的功能，这就是事件代理。

使用事件代理主要有两个优势：

1. 减少事件绑定，提升性能。之前你需要绑定一堆子节点，而现在你只需要绑定一个父节点即可。减少了绑定事件监听函数的数量。
2. 动态变化的 DOM 结构，仍然可以监听。当一个 DOM 动态创建之后，不会带有任何事件监听，除非你重新执行事件监听函数，而使用事件监听无须担忧这个问题。

# 事件对象
当一个事件被触发的时候，会创建一个事件对象（Event Object），这个对象里面包含了一些有用的属性或者方法。事件对象会作为第一个参数，传递给我们的毁掉函数。

事件对象包括很多有用的信息，比如事件触发时，鼠标在屏幕上的坐标、被触发的 DOM 详细信息、以及上图最下面继承过来的停止冒泡方法（stopPropagation）。
下面介绍一下比较常用的几个属性和方法：

type (string)
事件的名称，比如 “click”。

target(node)
事件要触发的目标节点。

bubbles (boolean)
表明该事件是否是在冒泡阶段触发的。

preventDefault (function)
这个方法可以禁止一切默认的行为，例如点击 a 标签时，会打开一个新页面，如果为 a 标签监听事件 click 同时调用该方法，则不会打开新页面。

stopPropagation (function)
用于阻止事件冒泡。
比较复杂的应用，由于事件监听比较复杂，可能会希望只监听发生在具体节点的事件，这个时候就需要停止事件冒泡。

cancelable (boolean)
这个属性表明该事件是否可以通过调用 event.preventDefault 方法来禁用默认行为。

ventPhase (number)
这个属性的数字表示当前事件触发在什么阶段。none: 0; 捕获: 1; 目标: 2; 冒泡: 3。

pageX 和 pageY (number)
这两个属性表示触发事件时，鼠标相对于页面的坐标

isTrusted (boolean)
表明该事件是浏览器触发（用户真实操作触发），还是 JavaScript 代码触发的。

# jQuery中的事件
如果你在写文章或者Demo，为了简单，你当然可以用上面的事件监听函数，以及那些事件对象提供的方法等。但在实际中，有一些方法和属性是有兼容性问题的，所以我们会使用jQuery 来消除兼容性问题。
jQuery 中事件的基础操作：

## 绑定事件和事件代理
在 jQuery 中，提供了诸如 click() 这样的语法糖来绑定对应事件，但是这里推荐统一使用 on() 来绑定事件。语法：

.on( events, [selector], [ data ], handler )
events 即为事件的名称，你可以传递第二个参数来实现事件代理，具体看文档.on()

## 处理过兼容性的事件对象（Event Object）
事件对象有些方法等也有兼容性差异，jQuery 将其封装处理，并提供跟标准一直的命名。
如果你想在 jQuery 事件回调函数中访问原来的事件对象，需要使用 event.originalEvent，它指向原生的事件对象。

## 触发事件 trigger 方法
点击某个绑定了 click 事件的节点，自然会触发该节点的 click 事件，从而执行对应回调函数。
trigger 方法可以模拟触发事件，我们单击另一个节点 elementB，可以使用：
$(elementB).on('click', function(){
    $(elementA).trigger( "click" );
});

# 事件进阶话题

## IE 浏览器的差异和兼容性问题
IE 中 Event 对象需要注意的地方
IE 中往回调函数中传递的事件对象与标准也有一些差异，你需要使用 window.event 来获取事件对象。所以你通常会写出下面代码来获取事件对象：
event = event || window.event

此外还有一些事件属性有差别，比如比较常用的 event.target 属性，IE 中没有，而是使用 event.srcElement 来代替。如果你的回调函数需要处理触发事件的节点，那么需要写：
node = event.srcElement || event.target;

## 常用事件和技巧

### load
beforeunload 事件在资源加载完成时触发。这个资源可以是图片、CSS 文件、JS 文件、视频、document 和 window 等等。
比较常用的就是监听 window 的 load 事件，当页面内所有资源全部加载完成之后就会触发。比如用 JS 对图片以及其他资源处理，我们在 load 事件中触发，可以保证 JS 不会在资源未加载完成就开始处理资源导致报错。
当浏览者输入信息但未保存时关掉网页，我们就可以开始监听这个事件，例如：

window.addEventListener("beforeunload", function( event ) {
    event.returnValue = "放弃当前未保存内容而关闭页面？";
});

### error
当我们加载资源失败或者加载成功但是只加载一部分而无法使用时，就会触发 error 事件，我们可以通过监听该事件来提示一个友好的报错或者进行其他处理。比如 JS 资源加载失败，则提示尝试刷新；图片资源加载失败，在图片下面提示图片加载失败等。该事件不会冒泡。因为子节点加载失败，并不意味着父节点加载失败，所以你的处理函数必须精确绑定到目标节点。

需要注意的是，对于该事件，可以使用 addEventListener 等进行监听，但是有时候会出现失效情况（看这个例子），这是因为 error 事件都触发过了，你的 JS 监听处理代码还没有加载进来执行。为了避免这种情况，用内联法更好一些：

<img src="not-found.jpg" onerror="doSomething" />

# 参考资源

[javascript和事件](http://yujiangshui.com/javascript-event/#事件的-Event-对象)
