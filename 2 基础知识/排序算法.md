# 排序算法

标签（空格分隔）： 知识理论

---

# 介绍

在计算机科学所使用的排序算法通常被分类为：

- 计算的 时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是 O(n log n)，且坏的性能是 O(n^2)。对于一个排序理想的性能是 O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要 O(n log n)。

- 存储器使用量（以及其他电脑资源的使用）

- 稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R 和 S，且在原本的列表中 R 出现在 S 之前，在排序过的列表中 R 也将会是在 S 之前。

- 依据排序的方法：插入、交换、选择、合并等等。

重要：以下三种排序算法都十分低效, 因此实际应用中不要使用这三种算法, 遇到需要排序的问题, 应该首先使用 JavaScript 内置的方法 Array.prototype.sort();。

# 三种基础的排序算法

## 冒泡

冒泡排序对一个需要进行排序的数组进行以下操作:

1. 比较第一项和第二项;
1. 如果第一项应该排在第二项之后, 那么两者交换顺序;
1. 比较第二项和第三项;
1. 如果第二项应该排在第三项之后, 那么两者交换顺序;
1. 以此类推直到完成排序;

代码实现：

    function swap(items, firstIndex, secondIndex){
      var temp = items[firstIndex];
      items[firstIndex] = items[secondIndex];
      items[secondIndex] = temp;
    };

    function bubbleSort(items){
      var len = items.length, i, j, stop;

      for (i = 0; i < len; i++){
        for (j = 0, stop = len-i; j < stop; j++){
          if (items[j] > items[j+1]){
            swap(items, j, j+1);
          }
        }
      }
      return items;
    }

外层的循环决定需要进行多少次遍历, 内层的循环负责数组内各项的比较, 还通过外层循环的次数和数组长度决定何时停止比较.

冒泡排序极其低效, 因为处理数据的步骤太多, 对于数组中的每 n 项, 都需要 n^2 次操作来实现该算法(实际比 n^2 略小, 但可以忽略, 具体原因见 ⤵️), 即时间复杂度为 O(n^2).

## 选择

选择排序对一个需要进行排序的数组进行以下操作:

1. 假定数组中的第一项为最小值(min);
1. 比较第一项和第二项的值;
1. 若第二项比第一项小, 则假定第二项为最小值;
1. 以此类推直到排序完成.

代码实现：

    function swap(items, firstIndex, secondIndex){
      var temp = items[firstIndex];
      items[firstIndex] = items[secondIndex];
      items[secondIndex] = temp;
    };

    function selectionSort(){
      let items = [...document.querySelectorAll('.num-queue span')].map(num => +num.textContent);
      let len = items.length, min;

      for (i = 0; i < len; i++){
        min = i;
        for(j = i + 1; j < len; j++){
          if(items[j] < items[min]){
            min = j;
          }
        }
        if(i != min){
          swap(items, i, min);
        }
      }
      return items;
    };

外层循环决定每次遍历的初始位置, 从数组的第一项开始直到最后一项. 内层循环决定哪一项元素被比较.

选择排序的时间复杂度为 O(n^2).

## 插入

与上述两种排序算法不同, 插入排序是稳定排序算法(stable sort algorithm), 稳定排序算法指不改变列表中相同元素的位置, 冒泡排序和选择排序不是稳定排序算法, 因为排序过程中有可能会改变相同元素位置. 对简单的值(数字或字符串)排序时, 相同元素位置改变与否影响不是很大. 而当列表中的元素是对象, 根据对象的某个属性对列表进行排序时, 使用稳定排序算法就很有必要了.

一旦算法包含交换(swap)这个步骤, 就不可能是稳定的排序算法. 列表内元素不断交换, 无法保证先前的元素排列为止一直保持原样. 而插入排序的实现过程不包含交换, 而是提取某个元素将其插入数组中正确位置.

插入排序的实现是将一个数组分为两个部分, 一部分排序完成, 一部分未进行排序. 初始状态下整个数组属于未排序部分, 排序完成部分为空. 然后进行排序, 数组内的第一项被加入排序完成部分, 由于只有一项, 自然属于排序完成状态. 然后对未完成排序的余下部分的元素进行如下操作:

1. 如果这一项的值应该在排序完成部分最后一项元素之后, 保留这一项在原有位置开始下一步;
1. 如果这一项的值应该排在排序完成部分最后一项元素之前, 将这一项从未完成部分暂时移开, 将已完成部分的最后一项元素移后一个位置;
1. 被暂时移开的元素与已完成部分倒数第二项元素进行比较;
1. 如果被移除元素的值在最后一项与倒数第二项的值之间, 那么将其插入两者之间的位置, 否则继续与前面的元素比较, 将暂移出的元素放置已完成部分合适位置. 以此类推直到所有元素都被移至排序完成部分.

代码实现：

    function insertionSort(items) {
      let len = items.length, value, i, j;
      for (i = 0; i < len; i++) {
        value = items[i];
        for (j = i-1; j > -1 && items[j] > value; j--) {
          items[j+1] = items[j];
        }
        items[j+1] = value;
      }
      return items;
    };

外层循环的遍历顺序是从数组的第一位到最后一位, 内层循环的遍历则是从后往前, 内层循环同时负责元素的移位.

插入排序的时间复杂度为 O(n^2)

## 重要：

以下三种排序算法都十分低效, 因此实际应用中不要使用这三种算法, 遇到需要排序的问题, 应该首先使用 JavaScript 内置的方法 Array.prototype.sort();。
